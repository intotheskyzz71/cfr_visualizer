<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CFR Visualizer v3 - Enhanced Money Flow Investigation Tool</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Sarabun:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        .layer-label {
            fill: #1a73e8;
            font-weight: 600;
            font-size: 14px;
            font-family: 'Sarabun', sans-serif;
            pointer-events: none;
        }
        
        .layer-label-bg {
            fill: white;
            stroke: #1a73e8;
            stroke-width: 2;
            rx: 6;
            transition: all 0.2s;
        }
        
        .layer-labels g:hover .layer-label-bg {
            stroke-width: 3;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f5f5;
            color: #1a1a1a;
            overflow: hidden;
        }
        
        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: white;
            border-bottom: 1px solid #e0e0e0;
            padding: 10px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .version-badge {
            background: #1a73e8;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .file-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn {
            padding: 6px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .btn-primary {
            background: #1a73e8;
            color: white;
        }
        
        .btn-primary:hover {
            background: #1557b0;
        }
        
        .btn-secondary {
            background: white;
            color: #1a1a1a;
            border: 1px solid #e0e0e0;
        }
        
        .btn-secondary:hover {
            background: #f8f9fa;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 10px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 0.875rem;
            color: #666;
        }
        
        .main-content {
            flex: 1;
            position: relative;
            background: #fafafa;
            overflow: hidden;
        }
        
        #network-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .controls-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 200px;
            max-width: 250px;
        }
        
        .control-section {
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid #eee;
        }
        
        .control-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .control-label {
            font-family: 'Sarabun', sans-serif;
            font-size: 0.8rem;
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }
        
        .control-group {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        /* Context Menu Styles */
        .context-menu {
            position: absolute;
            background: white;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            border: 1px solid #e0e0e0;
            z-index: 10000;
            display: none;
            min-width: 120px;
        }
        
        .context-menu-section {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .context-menu-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .context-menu-label {
            font-family: 'Sarabun', sans-serif;
            font-size: 0.7rem;
            color: #666;
            font-weight: 600;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .theme-icons {
            display: flex;
            gap: 4px;
            justify-content: center;
        }
        
        .theme-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.6rem;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .theme-icon:hover {
            transform: scale(1.1);
            border-color: rgba(26, 115, 232, 0.5);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .theme-icon.active {
            border-color: #1a73e8;
            border-width: 3px;
            transform: scale(1.05);
        }
        
        .theme-icon.dark { background: linear-gradient(135deg, #2c3e50, #34495e); }
        .theme-icon.red { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .theme-icon.yellow { background: linear-gradient(135deg, #f39c12, #e67e22); }
        .theme-icon.gray { background: linear-gradient(135deg, #95a5a6, #7f8c8d); }
        
        .action-icons {
            display: flex;
            justify-content: center;
        }
        
        .action-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
        }
        
        .action-icon:hover {
            transform: scale(1.05);
            border-color: #ff5252;
            background: #fff5f5;
            box-shadow: 0 2px 8px rgba(255, 82, 82, 0.2);
        }
        
        .action-icon svg {
            color: #ff5252;
            transition: color 0.2s ease;
        }
        
        .action-icon:hover svg {
            color: #d32f2f;
        }
        
        .header-right {
            display: flex;
            align-items: center;
        }
        
        /* Contact Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            backdrop-filter: blur(4px);
        }
        
        .modal {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            position: relative;
        }
        
        .modal-overlay.show .modal {
            transform: scale(1);
        }
        
        .modal-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .modal-title {
            font-family: 'Sarabun', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            color: #1a73e8;
            margin: 0;
        }
        
        .modal-content {
            font-family: 'Sarabun', sans-serif;
            line-height: 1.8;
            color: #333;
        }
        
        .contact-info {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            margin: 12px 0;
        }
        
        .contact-info p {
            margin: 8px 0;
            font-size: 0.95rem;
        }
        
        .contact-name {
            font-weight: 700;
            color: #1a73e8;
            font-size: 1.1rem !important;
        }
        
        .contact-position {
            font-weight: 600;
            color: #666;
            font-size: 0.9rem !important;
        }
        
        .contact-detail {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0 !important;
        }
        
        .contact-detail svg {
            color: #1a73e8;
            flex-shrink: 0;
        }
        
        .modal-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .modal-close:hover {
            background: #f0f0f0;
            color: #666;
        }
        
        .node-rect.theme-dark { fill: #34495e; stroke: #2c3e50; stroke-width: 2; }
        .node-rect.theme-red { fill: #fadbd8; stroke: #e74c3c; stroke-width: 2; }
        .node-rect.theme-yellow { fill: #fef9e7; stroke: #f39c12; stroke-width: 2; }
        .node-rect.theme-gray { fill: #f8f9fa; stroke: #95a5a6; stroke-width: 2; }
        
        .deleted-node {
            opacity: 0.3;
            pointer-events: none;
        }
        
        .deleted-node .node-rect {
            fill: #ff6b6b;
            stroke: #ff5252;
            stroke-dasharray: 5,5;
        }
        
        /* Network styles */
        .node {
            cursor: pointer;
        }
        
        .node:hover .node-rect {
            stroke: #1a73e8;
            stroke-width: 3;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
        }
        
        .node-rect {
            fill: white;
            stroke: #ddd;
            stroke-width: 2;
            rx: 8;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .node-rect.victim {
            fill: #e8f5e9;
            stroke: #4caf50;
            stroke-width: 3;
        }
        
        .node-rect.intermediate {
            fill: #fff3e0;
            stroke: #ff9800;
        }
        
        .node-label {
            font-family: 'Sarabun', sans-serif;
            font-size: 13px;
            pointer-events: none;
        }
        
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2;
            opacity: 0.6;
            transition: all 0.3s;
        }
        
        .link:hover {
            stroke: #1a73e8;
            opacity: 1;
        }
        
        .link-label {
            font-family: 'Sarabun', sans-serif;
            font-size: 11px;
            fill: #666;
            background: white;
            padding: 2px 4px;
        }
        
        .link-label-bg {
            fill: white;
            stroke: #ddd;
            stroke-width: 1;
            rx: 3;
        }
        
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            font-size: 0.875rem;
            font-family: 'Sarabun', sans-serif;
            z-index: 1000;
            display: none;
            max-width: 350px;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e0e0e0;
            border-top-color: #1a73e8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 2v10l6 6"/>
                    </svg>
                    CFR Visualizer
                </h1>
                
                <div class="file-controls">
                    <div class="file-input-wrapper">
                        <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" multiple>
                        <label for="fileInput" class="btn btn-primary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="17 8 12 3 7 8"/>
                                <line x1="12" y1="3" x2="12" y2="15"/>
                            </svg>
                            เลือกไฟล์
                        </label>
                    </div>
                    <div id="fileInfo" class="file-info" style="display: none;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                            <polyline points="14 2 14 8 20 8"/>
                        </svg>
                        <span id="fileName"></span>
                    </div>
                    <button class="btn btn-primary" id="analyzeBtn" disabled>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8"/>
                            <path d="m21 21-4.35-4.35"/>
                        </svg>
                        วิเคราะห์
                    </button>
                </div>
            </div>
            
            <div class="header-right">
                <button class="btn btn-secondary" id="contactBtn" title="ติดต่อผู้พัฒนา">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                        <circle cx="12" cy="17" r="0.5" fill="currentColor"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="main-content">
            <div id="network-container">
                <svg id="network"></svg>
            </div>
            
            <div class="controls-overlay">
                <div class="control-section">
                    <div class="control-label">การซูม</div>
                    <div class="control-group">
                        <button class="btn btn-secondary" id="zoomInBtn" title="ซูมเข้า">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="m21 21-4.35-4.35"/>
                                <line x1="11" y1="8" x2="11" y2="14"/>
                                <line x1="8" y1="11" x2="14" y2="11"/>
                            </svg>
                        </button>
                        <button class="btn btn-secondary" id="zoomOutBtn" title="ซูมออก">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="m21 21-4.35-4.35"/>
                                <line x1="8" y1="11" x2="14" y2="11"/>
                            </svg>
                        </button>
                        <button class="btn btn-secondary" id="fitBtn" title="พอดีหน้าจอ">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                            </svg>
                        </button>
                        <button class="btn btn-secondary" id="resetBtn" title="รีเซ็ต">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="1 4 1 10 7 10"/>
                                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                            </svg>
                        </button>
                    </div>
                </div>
                
            </div>
            
            <div class="loading-overlay" id="loadingOverlay" style="display: none;">
                <div>
                    <div class="spinner"></div>
                    <p style="margin-top: 10px; color: #666; font-family: 'Sarabun', sans-serif;">กำลังประมวลผล...</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <!-- Contact Modal -->
    <div class="modal-overlay" id="contactModal">
        <div class="modal">
            <button class="modal-close" id="closeModal">&times;</button>
            <div class="modal-header">
                <h2 class="modal-title">พบปัญหา / ติดต่อผู้พัฒนาระบบ</h2>
            </div>
            <div class="modal-content">
                <div class="contact-info">
                    <p class="contact-name">ร.ต.อ.พลวัฒน์ วิริยะโชติวิบูล</p>
                    <p class="contact-position">รอง สว.(สอบสวน) กก.3 บก.สอท.1</p>
                    <div class="contact-detail">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
                        </svg>
                        <span>โทร 086-445-9351</span>
                    </div>
                    <div class="contact-detail">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                        </svg>
                        <span>LINE ID: bpp9351</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-section">
            <div class="context-menu-label">สี</div>
            <div class="theme-icons">
                <div class="theme-icon dark" data-theme="dark" title="เข้ม">●</div>
                <div class="theme-icon red" data-theme="red" title="แดง">●</div>
                <div class="theme-icon yellow" data-theme="yellow" title="เหลือง">●</div>
                <div class="theme-icon gray" data-theme="gray" title="เทา">●</div>
            </div>
        </div>
        <div class="context-menu-section">
            <div class="context-menu-label">การจัดการ</div>
            <div class="action-icons">
                <div class="action-icon" id="deleteNode" title="ลบ/กู้คืน Node">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="m19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        <line x1="10" y1="11" x2="10" y2="17"/>
                        <line x1="14" y1="11" x2="14" y2="17"/>
                    </svg>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // Application state
        const app = {
            data: [],
            network: null,
            simulation: null,
            zoom: null,
            svg: null,
            g: null,
            pinnedNode: null,
            currentTheme: 'dark',
            deletedNodes: new Set(),
            contextMenu: {
                visible: false,
                targetNode: null,
                x: 0,
                y: 0
            }
        };

        // Utility functions
        const utils = {
            thaiMonths: {
                'มกราคม': '01', 'กุมภาพันธ์': '02', 'มีนาคม': '03', 'เมษายน': '04',
                'พฤษภาคม': '05', 'มิถุนายน': '06', 'กรกฎาคม': '07', 'สิงหาคม': '08',
                'กันยายน': '09', 'ตุลาคม': '10', 'พฤศจิกายน': '11', 'ธันวาคม': '12',
                'ม.ค.': '01', 'ก.พ.': '02', 'มี.ค.': '03', 'เม.ย.': '04',
                'พ.ค.': '05', 'มิ.ย.': '06', 'ก.ค.': '07', 'ส.ค.': '08',
                'ก.ย.': '09', 'ต.ค.': '10', 'พ.ย.': '11', 'ธ.ค.': '12'
            },
            
            thaiToArabic(str) {
                if (!str) return str;
                const thaiNumbers = '๐๑๒๓๔๕๖๗๘๙';
                const arabicNumbers = '0123456789';
                let result = str.toString();
                for (let i = 0; i < thaiNumbers.length; i++) {
                    result = result.replace(new RegExp(thaiNumbers[i], 'g'), arabicNumbers[i]);
                }
                return result;
            },
            
            parseDate(dateValue) {
                if (!dateValue) return null;
                try {
                    let dateStr = this.thaiToArabic(dateValue.toString());
                    
                    // Excel serial date
                    if (!isNaN(dateStr) && dateStr > 25569) {
                        const date = new Date((dateStr - 25569) * 86400 * 1000);
                        return date;
                    }
                    
                    // Thai date format (e.g., "13 มีนาคม 2568")
                    for (let [thaiMonth, monthNum] of Object.entries(this.thaiMonths)) {
                        if (dateStr.includes(thaiMonth)) {
                            const parts = dateStr.split(' ');
                            const day = parseInt(parts[0]);
                            const month = parseInt(monthNum) - 1;
                            let year = parseInt(parts[2]);
                            // Convert Buddhist year to Gregorian if needed
                            if (year > 2500) {
                                year = year - 543;
                            }
                            return new Date(year, month, day);
                        }
                    }
                    
                    // DD/MM/YYYY format
                    const dateRegex = /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/;
                    const match = dateStr.match(dateRegex);
                    if (match) {
                        const day = parseInt(match[1]);
                        const month = parseInt(match[2]) - 1;
                        let year = parseInt(match[3]);
                        // Convert Buddhist year to Gregorian if needed
                        if (year > 2500) {
                            year = year - 543;
                        }
                        return new Date(year, month, day);
                    }
                    
                    // YYYY-MM-DD format
                    const isoRegex = /(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})/;
                    const isoMatch = dateStr.match(isoRegex);
                    if (isoMatch) {
                        let year = parseInt(isoMatch[1]);
                        const month = parseInt(isoMatch[2]) - 1;
                        const day = parseInt(isoMatch[3]);
                        // Convert Buddhist year to Gregorian if needed
                        if (year > 2500) {
                            year = year - 543;
                        }
                        return new Date(year, month, day);
                    }
                    
                    return new Date(dateStr);
                } catch (e) {
                    console.error('Date parsing error:', e);
                    return null;
                }
            },
            
            parseTime(timeValue) {
                if (!timeValue) return null;
                try {
                    let timeStr = this.thaiToArabic(timeValue.toString());
                    
                    // Excel time
                    if (!isNaN(timeStr) && timeStr < 1) {
                        const totalMinutes = Math.round(timeStr * 24 * 60);
                        const hours = Math.floor(totalMinutes / 60);
                        const minutes = totalMinutes % 60;
                        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                    }
                    
                    // HH:MM:SS format
                    const timeRegex = /(\d{1,2}):(\d{2})/;
                    const match = timeStr.match(timeRegex);
                    if (match) {
                        const hours = match[1].padStart(2, '0');
                        const minutes = match[2];
                        return `${hours}:${minutes}`;
                    }
                    
                    return timeStr;
                } catch (e) {
                    return timeValue;
                }
            },
            
            parseAmount(amountValue) {
                if (!amountValue) return 0;
                try {
                    let amountStr = this.thaiToArabic(amountValue.toString());
                    amountStr = amountStr.replace(/[฿$,]/g, '').trim();
                    const amount = parseFloat(amountStr);
                    return isNaN(amount) ? 0 : amount;
                } catch (e) {
                    return 0;
                }
            },
            
            formatAmount(amount) {
                return amount.toLocaleString('th-TH', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 2
                });
            },
            
            formatDate(date) {
                if (!date) return '';
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const year = date.getFullYear() + 543;
                return `${day}/${month}/${year}`;
            }
        };

        // Network visualization module
        const networkVis = {
            init() {
                const container = document.getElementById('network-container');
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                app.svg = d3.select('#network')
                    .attr('width', width)
                    .attr('height', height);
                
                // Clear previous
                app.svg.selectAll('*').remove();
                
                // Create main group
                app.g = app.svg.append('g').attr('class', 'main-group');
                
                // Create defs for markers
                const defs = app.svg.append('defs');
                
                // Create arrow marker with better positioning
                defs.append('marker')
                    .attr('id', 'arrow-default')
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 10) // Position arrow at tip
                    .attr('refY', 0)
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 10)
                    .attr('orient', 'auto')
                    .attr('markerUnits', 'userSpaceOnUse')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', '#666');
                
                // Create arrow for victim links
                defs.append('marker')
                    .attr('id', 'arrow-victim')
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 10)
                    .attr('refY', 0)
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 10)
                    .attr('orient', 'auto')
                    .attr('markerUnits', 'userSpaceOnUse')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', '#4caf50');
                
                // Setup zoom
                app.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        app.g.attr('transform', event.transform);
                    });
                
                app.svg.call(app.zoom);
                
                return { width, height };
            },
            
            render(data) {
                const { width, height } = this.init();
                
                // Calculate hierarchical layout
                const layers = this.calculateLayers(data.nodes, data.links);
                
                // Enhanced positioning with collision avoidance
                const nodeSpacing = 280; // Increased spacing
                const layerSpacing = 220; // Increased layer spacing
                const startY = 120;
                const maxNodesPerRow = 6; // Limit nodes per row
                
                layers.forEach((layer, layerIndex) => {
                    // Split large layers into multiple rows
                    const rows = this.splitIntoRows(layer, maxNodesPerRow);
                    
                    rows.forEach((row, rowIndex) => {
                        const rowWidth = row.length * nodeSpacing;
                        const startX = (width - rowWidth) / 2 + nodeSpacing / 2;
                        const currentY = startY + layerIndex * layerSpacing + rowIndex * 100;
                        
                        row.forEach((node, nodeIndex) => {
                            node.x = startX + nodeIndex * nodeSpacing;
                            node.y = currentY;
                            node.layer = layerIndex;
                            node.row = rowIndex;
                        });
                    });
                });
                
                // Create layer labels
                const layerLabelGroup = app.g.append('g').attr('class', 'layer-labels');
                
                layers.forEach((layer, layerIndex) => {
                    // Find leftmost node in this layer
                    const leftmostX = Math.min(...layer.map(node => node.x));
                    const labelX = leftmostX - 150; // Position to the left of leftmost node
                    const labelY = startY + layerIndex * layerSpacing;
                    
                    const labelGroup = layerLabelGroup.append('g')
                        .attr('transform', `translate(${labelX}, ${labelY})`)
                        .style('cursor', 'move')
                        .call(this.dragLabel());
                    
                    // Store initial position for drag
                    labelGroup.datum({x: labelX, y: labelY});
                    
                    // Background rectangle
                    const bg = labelGroup.append('rect')
                        .attr('class', 'layer-label-bg')
                        .attr('y', -10)
                        .attr('height', 20);
                    
                    // Label text
                    const text = labelGroup.append('text')
                        .attr('class', 'layer-label')
                        .attr('text-anchor', 'middle')
                        .attr('x', 0)
                        .attr('dy', '0.35em')
                        .text(`บัญชีแถวที่ ${layerIndex}`);
                    
                    // Adjust background size
                    const bbox = text.node().getBBox();
                    bg.attr('x', -bbox.width/2 - 12)
                        .attr('width', bbox.width + 24);
                });
                
                // Create links with curved paths
                const linkGroup = app.g.append('g').attr('class', 'links');
                
                const links = linkGroup.selectAll('path')
                    .data(data.links)
                    .join('path')
                    .attr('class', 'link')
                    .attr('d', d => this.createCurvedPath(d))
                    .attr('marker-end', d => {
                        const source = data.nodes.find(n => n.id === d.source);
                        if (source && source.isVictim) return 'url(#arrow-victim)';
                        return 'url(#arrow-default)';
                    })
                    .attr('stroke-width', d => Math.min(Math.sqrt(d.totalAmount / 100000) + 1, 6));
                
                // Create link labels
                const labelGroup = app.g.append('g').attr('class', 'link-labels');
                
                data.links.forEach((link, i) => {
                    const source = data.nodes.find(n => n.id === link.source);
                    const target = data.nodes.find(n => n.id === link.target);
                    const midPoint = this.getCurvedMidpoint(source, target);
                    
                    const group = labelGroup.append('g')
                        .attr('transform', `translate(${midPoint.x}, ${midPoint.y})`);
                    
                    // Background
                    const bg = group.append('rect')
                        .attr('class', 'link-label-bg');
                    
                    // Text
                    const text = group.append('text')
                        .attr('class', 'link-label')
                        .attr('text-anchor', 'middle');
                    
                    // Show all transactions
                    let yOffset = -(link.transactions.length * 14) / 2;
                    link.transactions.forEach((tx, txIndex) => {
                        text.append('tspan')
                            .attr('x', 0)
                            .attr('dy', txIndex === 0 ? yOffset : 14)
                            .text(`${utils.formatDate(tx.date)} ${tx.time} ฿${utils.formatAmount(tx.amount)}`);
                    });
                    
                    // Adjust background
                    const bbox = text.node().getBBox();
                    bg.attr('x', bbox.x - 4)
                        .attr('y', bbox.y - 2)
                        .attr('width', bbox.width + 8)
                        .attr('height', bbox.height + 4);
                });
                
                // Create nodes
                const nodeGroup = app.g.append('g').attr('class', 'nodes');
                
                const nodes = nodeGroup.selectAll('g')
                    .data(data.nodes)
                    .join('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.x}, ${d.y})`)
                    .call(this.drag());
                
                // Node rectangles
                const nodeWidth = 180;
                const nodeHeight = 70;
                
                nodes.append('rect')
                    .attr('class', d => {
                        if (d.isVictim) return 'node-rect victim';
                        if (d.layer > 0 && d.layer < layers.length - 1) return 'node-rect intermediate';
                        return 'node-rect';
                    })
                    .attr('x', -nodeWidth/2)
                    .attr('y', -nodeHeight/2)
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight);
                
                // Node text
                const nodeText = nodes.append('text')
                    .attr('class', 'node-label')
                    .attr('text-anchor', 'middle');
                
                // Bank and account
                nodeText.append('tspan')
                    .attr('x', 0)
                    .attr('y', -20)
                    .attr('font-weight', 600)
                    .attr('font-size', 14)
                    .text(d => `${d.bank}-${d.account}`);
                
                // Name
                nodeText.append('tspan')
                    .attr('x', 0)
                    .attr('y', 0)
                    .text(d => d.name || '-');
                
                // ID or Victim label
                nodeText.append('tspan')
                    .attr('x', 0)
                    .attr('y', 20)
                    .attr('font-size', 12)
                    .attr('fill', d => d.isVictim ? '#4caf50' : '#666')
                    .attr('font-weight', d => d.isVictim ? 600 : 400)
                    .text(d => {
                        if (d.isVictim) return '**ผู้เสียหาย**';
                        return d.personalId ? `ID: ${d.personalId}` : '';
                    });
                
                // Events
                nodes.on('mouseover', (event, d) => {
                        // Only show tooltip on hover if no node is pinned
                        if (!app.pinnedNode) {
                            this.showTooltip(event, d);
                        }
                    })
                    .on('mouseout', () => {
                        // Only hide tooltip if no node is pinned
                        if (!app.pinnedNode) {
                            this.hideTooltip();
                        }
                    })
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        
                        // Hide context menu if visible
                        this.hideContextMenu();
                        
                        // Toggle pinned tooltip
                        if (app.pinnedNode === d.id) {
                            app.pinnedNode = null;
                            this.hideTooltip();
                        } else {
                            app.pinnedNode = d.id;
                            this.showTooltip(event, d);
                        }
                    })
                    .on('contextmenu', (event, d) => {
                        event.preventDefault();
                        event.stopPropagation();
                        
                        // Hide tooltip if visible
                        this.hideTooltip();
                        app.pinnedNode = null;
                        
                        // Show context menu
                        this.showContextMenu(event, d);
                    });
                
                // Click on background to clear pinned tooltip and context menu
                app.svg.on('click', () => {
                    if (app.pinnedNode) {
                        app.pinnedNode = null;
                        this.hideTooltip();
                    }
                    this.hideContextMenu();
                });
                
                links.on('mouseover', function(event, d) {
                    d3.select(this)
                        .attr('stroke', '#1a73e8')
                        .attr('opacity', 1)
                        .attr('stroke-width', d => Math.min(Math.sqrt(d.totalAmount / 100000) + 2, 8));
                })
                .on('mouseout', function(event, d) {
                    d3.select(this)
                        .attr('stroke', null)
                        .attr('opacity', 0.6)
                        .attr('stroke-width', d => Math.min(Math.sqrt(d.totalAmount / 100000) + 1, 6));
                });
                
                // Fit to screen
                setTimeout(() => this.fitToScreen(), 500);
            },
            
            splitIntoRows(layer, maxNodesPerRow) {
                const rows = [];
                for (let i = 0; i < layer.length; i += maxNodesPerRow) {
                    rows.push(layer.slice(i, i + maxNodesPerRow));
                }
                return rows;
            },
            
            calculateLayers(nodes, links) {
                // Find victim nodes
                const victims = nodes.filter(n => n.isVictim);
                const layers = [];
                const visited = new Set();
                
                // Layer 0: Victims
                layers[0] = victims;
                victims.forEach(v => visited.add(v.id));
                
                // Build adjacency list
                const adjacency = new Map();
                nodes.forEach(n => adjacency.set(n.id, []));
                links.forEach(link => {
                    adjacency.get(link.source).push(link.target);
                });
                
                // BFS to assign layers
                let currentLayer = 0;
                while (visited.size < nodes.length) {
                    const nextLayer = [];
                    
                    // Find nodes connected to current layer
                    layers[currentLayer].forEach(node => {
                        const neighbors = adjacency.get(node.id) || [];
                        neighbors.forEach(neighborId => {
                            if (!visited.has(neighborId)) {
                                visited.add(neighborId);
                                const neighbor = nodes.find(n => n.id === neighborId);
                                if (neighbor) nextLayer.push(neighbor);
                            }
                        });
                    });
                    
                    if (nextLayer.length > 0) {
                        currentLayer++;
                        layers[currentLayer] = nextLayer;
                    } else {
                        // Add remaining nodes to last layer
                        const remaining = nodes.filter(n => !visited.has(n.id));
                        if (remaining.length > 0) {
                            currentLayer++;
                            layers[currentLayer] = remaining;
                            remaining.forEach(n => visited.add(n.id));
                        }
                        break;
                    }
                }
                
                return layers;
            },
            
            createCurvedPath(d) {
                const source = app.network.nodes.find(n => n.id === d.source);
                const target = app.network.nodes.find(n => n.id === d.target);
                
                if (!source || !target) return '';
                
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dr = Math.sqrt(dx * dx + dy * dy);
                
                // Node dimensions
                const nodeWidth = 180;
                const nodeHeight = 70;
                
                // Calculate angle from source to target
                const angle = Math.atan2(dy, dx);
                
                // Calculate start point (edge of source node)
                let sourceX, sourceY;
                if (Math.abs(dx) > Math.abs(dy) * (nodeWidth / nodeHeight)) {
                    // Exit from left or right side
                    sourceX = source.x + (dx > 0 ? nodeWidth / 2 : -nodeWidth / 2);
                    sourceY = source.y + (dx > 0 ? nodeWidth / 2 : -nodeWidth / 2) * Math.tan(angle);
                } else {
                    // Exit from top or bottom
                    sourceX = source.x + (dy > 0 ? nodeHeight / 2 : -nodeHeight / 2) / Math.tan(angle);
                    sourceY = source.y + (dy > 0 ? nodeHeight / 2 : -nodeHeight / 2);
                }
                
                // Calculate end point (edge of target node - accounting for arrow)
                const arrowOffset = 2;
                let targetX, targetY;
                if (Math.abs(dx) > Math.abs(dy) * (nodeWidth / nodeHeight)) {
                    // Enter from left or right side
                    targetX = target.x - (dx > 0 ? nodeWidth / 2 + arrowOffset : -nodeWidth / 2 - arrowOffset);
                    targetY = target.y - (dx > 0 ? nodeWidth / 2 + arrowOffset : -nodeWidth / 2 - arrowOffset) * Math.tan(angle);
                } else {
                    // Enter from top or bottom
                    targetX = target.x - (dy > 0 ? nodeHeight / 2 + arrowOffset : -nodeHeight / 2 - arrowOffset) / Math.tan(angle);
                    targetY = target.y - (dy > 0 ? nodeHeight / 2 + arrowOffset : -nodeHeight / 2 - arrowOffset);
                }
                
                // Enhanced curve calculation to avoid overlaps
                const midX = (sourceX + targetX) / 2;
                const midY = (sourceY + targetY) / 2;
                
                // Dynamic curve offset based on distance and potential overlaps
                let offset = Math.max(dr * 0.2, 50); // Minimum curve
                
                // Check if nodes are in same row/layer (horizontal) - use more curve
                if (Math.abs(source.y - target.y) < 50) {
                    offset = Math.max(offset, 80);
                }
                
                // Check for potential overlaps with other links - add randomness
                const linkIndex = app.network.links.indexOf(d);
                const variation = (linkIndex % 3 - 1) * 20; // -20, 0, or 20
                offset += variation;
                
                // Control points for smoother S-curve
                const controlX1 = midX - offset * Math.sin(angle);
                const controlY1 = midY + offset * Math.cos(angle);
                
                // For long distances, use cubic bezier for smoother curves
                if (dr > 300) {
                    const controlX2 = midX + offset * 0.3 * Math.sin(angle);
                    const controlY2 = midY - offset * 0.3 * Math.cos(angle);
                    return `M${sourceX},${sourceY} C${controlX1},${controlY1} ${controlX2},${controlY2} ${targetX},${targetY}`;
                } else {
                    return `M${sourceX},${sourceY} Q${controlX1},${controlY1} ${targetX},${targetY}`;
                }
            },
            
            getCurvedMidpoint(source, target) {
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dr = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // Calculate midpoint along the curve
                const midX = (source.x + target.x) / 2;
                const midY = (source.y + target.y) / 2;
                const offset = dr * 0.15; // Same curve amount as in createCurvedPath
                
                // Offset the label position to follow the curve
                return {
                    x: midX - offset * Math.sin(angle) * 0.5,
                    y: midY + offset * Math.cos(angle) * 0.5
                };
            },
            
            dragLabel() {
                function dragstarted(event, d) {
                    d3.select(this).raise().style('cursor', 'grabbing');
                }
                
                function dragged(event, d) {
                    d.x = event.x;
                    d.y = event.y;
                    d3.select(this).attr('transform', `translate(${d.x}, ${d.y})`);
                }
                
                function dragended(event, d) {
                    d3.select(this).style('cursor', 'move');
                }
                
                return d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended);
            },
            
            drag() {
                function dragstarted(event, d) {
                    d3.select(this).raise().classed('dragging', true);
                }
                
                function dragged(event, d) {
                    d.x = event.x;
                    d.y = event.y;
                    d3.select(this).attr('transform', `translate(${d.x}, ${d.y})`);
                    
                    // Update connected links with proper path recalculation
                    d3.selectAll('.link')
                        .filter(l => l.source === d.id || l.target === d.id)
                        .attr('d', l => networkVis.createCurvedPath(l));
                    
                    // Update link labels
                    app.network.links.forEach((link, i) => {
                        if (link.source === d.id || link.target === d.id) {
                            const source = app.network.nodes.find(n => n.id === link.source);
                            const target = app.network.nodes.find(n => n.id === link.target);
                            const midPoint = networkVis.getCurvedMidpoint(source, target);
                            
                            d3.select('.link-labels').select(`g:nth-child(${i + 1})`)
                                .attr('transform', `translate(${midPoint.x}, ${midPoint.y})`);
                        }
                    });
                }
                
                function dragended(event, d) {
                    d3.select(this).classed('dragging', false);
                }
                
                return d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended);
            },
            
            showTooltip(event, d) {
                const tooltip = document.getElementById('tooltip');
                
                let content = `<strong>${d.bank}-${d.account}</strong><br>`;
                content += d.name ? `ชื่อ: ${d.name}<br>` : '';
                
                // Format personal ID as text to avoid scientific notation
                if (d.personalId) {
                    const idText = d.personalId.toString();
                    content += `ID: ${idText}<br>`;
                }
                
                content += `<hr style="margin: 5px 0; opacity: 0.3;">`;
                
                // Separate transaction counts
                const incomingCount = app.network.links.filter(l => l.target === d.id)
                    .reduce((sum, l) => sum + l.transactions.length, 0);
                const outgoingCount = app.network.links.filter(l => l.source === d.id)
                    .reduce((sum, l) => sum + l.transactions.length, 0);
                
                content += `ธุรกรรมรับเงิน: ${incomingCount} รายการ<br>`;
                content += `ธุรกรรมโอนเงิน: ${outgoingCount} รายการ<br>`;
                content += `<hr style="margin: 5px 0; opacity: 0.3;">`;
                content += `ยอดรับเงิน: ฿${utils.formatAmount(d.totalIn)}<br>`;
                content += `ยอดโอนเงิน: ฿${utils.formatAmount(d.totalOut)}`;
                
                if (d.isVictim) {
                    content += `<br><span style="color: #4caf50; font-weight: 600;">*** ผู้เสียหาย ***</span>`;
                }
                
                // Add indicator if pinned
                if (app.pinnedNode === d.id) {
                    content += `<br><span style="color: #1a73e8; font-size: 0.75rem;">📌 คลิกอีกครั้งเพื่อซ่อน</span>`;
                }
                
                tooltip.innerHTML = content;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY + 10) + 'px';
            },
            
            hideTooltip() {
                document.getElementById('tooltip').style.display = 'none';
            },
            
            fitToScreen() {
                const bounds = app.g.node().getBBox();
                const parent = app.svg.node().parentElement;
                const fullWidth = parent.clientWidth;
                const fullHeight = parent.clientHeight;
                const width = bounds.width;
                const height = bounds.height;
                const midX = bounds.x + width / 2;
                const midY = bounds.y + height / 2;
                
                if (width === 0 || height === 0) return;
                
                const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
                const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
                
                app.svg.transition().duration(750).call(
                    app.zoom.transform,
                    d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
                );
            },
            
            toggleNodeDeletion(nodeId) {
                if (app.deletedNodes.has(nodeId)) {
                    // Restore node
                    app.deletedNodes.delete(nodeId);
                } else {
                    // Delete node
                    app.deletedNodes.add(nodeId);
                }
                
                // Update visual state
                d3.selectAll('.node')
                    .classed('deleted-node', d => app.deletedNodes.has(d.id));
                
                // Update links connected to deleted nodes
                d3.selectAll('.link')
                    .style('opacity', d => {
                        const sourceDeleted = app.deletedNodes.has(d.source);
                        const targetDeleted = app.deletedNodes.has(d.target);
                        return (sourceDeleted || targetDeleted) ? 0.1 : 0.6;
                    });
                    
                // Update link labels
                d3.selectAll('.link-labels g')
                    .style('opacity', function() {
                        const linkData = d3.select('.link').datum();
                        if (!linkData) return 1;
                        const sourceDeleted = app.deletedNodes.has(linkData.source);
                        const targetDeleted = app.deletedNodes.has(linkData.target);
                        return (sourceDeleted || targetDeleted) ? 0.1 : 1;
                    });
            },
            
            applyThemeToNodes(theme) {
                // Update all nodes with new theme
                app.network.nodes.forEach(node => {
                    if (!node.isVictim) {
                        node.theme = theme;
                    }
                });
                
                // Re-render node rectangles
                d3.selectAll('.node .node-rect')
                    .attr('class', d => {
                        let classes = 'node-rect';
                        if (d.isVictim) classes += ' victim';
                        else if (d.layer > 0 && d.layer < app.network.layers?.length - 1) classes += ' intermediate';
                        
                        // Add theme class for non-victim nodes
                        if (!d.isVictim && d.theme) classes += ` theme-${d.theme}`;
                        
                        return classes;
                    });
            },
            
            applyThemeToSingleNode(nodeId, theme) {
                // Update specific node theme
                const node = app.network.nodes.find(n => n.id === nodeId);
                if (node && !node.isVictim) {
                    node.theme = theme;
                    
                    // Re-render this node's rectangle
                    d3.selectAll('.node')
                        .filter(d => d.id === nodeId)
                        .select('.node-rect')
                        .attr('class', d => {
                            let classes = 'node-rect';
                            if (d.isVictim) classes += ' victim';
                            else if (d.layer > 0 && d.layer < app.network.layers?.length - 1) classes += ' intermediate';
                            
                            // Add theme class
                            if (!d.isVictim && d.theme) classes += ` theme-${d.theme}`;
                            
                            return classes;
                        });
                }
            },
            
            showContextMenu(event, node) {
                const contextMenu = document.getElementById('contextMenu');
                app.contextMenu.targetNode = node;
                app.contextMenu.visible = true;
                
                // Position context menu
                const x = event.pageX || event.clientX;
                const y = event.pageY || event.clientY;
                
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.style.display = 'block';
                
                // Update theme icons to show current node theme
                document.querySelectorAll('.theme-icon').forEach(icon => {
                    const theme = icon.dataset.theme;
                    if (node.theme === theme) {
                        icon.classList.add('active');
                    } else {
                        icon.classList.remove('active');
                    }
                });
                
                // Position adjustment to keep menu on screen
                setTimeout(() => {
                    const rect = contextMenu.getBoundingClientRect();
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;
                    
                    if (rect.right > windowWidth) {
                        contextMenu.style.left = (x - rect.width) + 'px';
                    }
                    if (rect.bottom > windowHeight) {
                        contextMenu.style.top = (y - rect.height) + 'px';
                    }
                }, 0);
            },
            
            hideContextMenu() {
                const contextMenu = document.getElementById('contextMenu');
                contextMenu.style.display = 'none';
                app.contextMenu.visible = false;
                app.contextMenu.targetNode = null;
            }
        };

        // Data processor
        const dataProcessor = {
            async readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const firstSheet = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheet];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                                raw: false,
                                defval: '',
                                blankrows: true
                            });
                            
                            // Clean column names
                            const cleanedData = jsonData.map(row => {
                                const cleanRow = {};
                                for (let key in row) {
                                    const cleanKey = key.trim();
                                    cleanRow[cleanKey] = row[key];
                                }
                                return cleanRow;
                            });
                            
                            resolve(cleanedData);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            },
            
            processTransactions(rawDataArray) {
                const allTransactions = [];
                let globalIndex = 0;
                
                // Process multiple files
                rawDataArray.forEach((rawData, fileIndex) => {
                    rawData.forEach((row, rowIndex) => {
                        const date = utils.parseDate(row.transfer_date);
                        const time = utils.parseTime(row.transfer_time);
                        const timestamp = date ? date.getTime() : Date.now();
                        
                        allTransactions.push({
                            id: globalIndex++,
                            fileIndex,
                            source: `${row.from_bank_short_name}-${row.from_account_no}`,
                            sourceName: row.from_account_name || '',
                            sourceBank: row.from_bank_short_name,
                            sourceAccount: row.from_account_no,
                            target: `${row.to_bank_short_name}-${row.to_account_no}`,
                            targetName: row.to_account_name || `${row.first_name || ''} ${row.last_name || ''}`.trim(),
                            targetBank: row.to_bank_short_name,
                            targetAccount: row.to_account_no,
                            targetId: row.to_id ? row.to_id.toString() : '',
                            amount: utils.parseAmount(row.transfer_amount),
                            date,
                            time,
                            timestamp,
                            description: row.transfer_description || ''
                        });
                    });
                });
                
                // Sort by timestamp
                allTransactions.sort((a, b) => a.timestamp - b.timestamp);
                
                return allTransactions;
            },
            
            buildNetwork(transactions) {
                const nodes = new Map();
                const linkMap = new Map();
                const victimSources = new Set();
                
                // Identify unique file sources as potential victims
                const fileVictims = new Set();
                transactions.forEach(tx => {
                    if (tx.fileIndex !== undefined) {
                        fileVictims.add(tx.source);
                    }
                });
                
                // Create nodes and aggregate transactions
                transactions.forEach((tx, index) => {
                    // Source node
                    if (!nodes.has(tx.source)) {
                        const isVictim = fileVictims.has(tx.source) || index === 0;
                        nodes.set(tx.source, {
                            id: tx.source,
                            bank: tx.sourceBank,
                            account: tx.sourceAccount,
                            name: tx.sourceName,
                            isVictim: isVictim,
                            transactionCount: 0,
                            totalIn: 0,
                            totalOut: 0,
                            theme: app.currentTheme
                        });
                    }
                    
                    // Target node
                    if (!nodes.has(tx.target)) {
                        nodes.set(tx.target, {
                            id: tx.target,
                            bank: tx.targetBank,
                            account: tx.targetAccount,
                            name: tx.targetName,
                            personalId: tx.targetId ? tx.targetId.toString() : '',
                            isVictim: false,
                            transactionCount: 0,
                            totalIn: 0,
                            totalOut: 0,
                            theme: app.currentTheme
                        });
                    }
                    
                    // Update node statistics
                    nodes.get(tx.source).transactionCount++;
                    nodes.get(tx.source).totalOut += tx.amount;
                    nodes.get(tx.target).transactionCount++;
                    nodes.get(tx.target).totalIn += tx.amount;
                    
                    // Create or update link
                    const linkKey = `${tx.source}->${tx.target}`;
                    if (!linkMap.has(linkKey)) {
                        linkMap.set(linkKey, {
                            source: tx.source,
                            target: tx.target,
                            transactions: [],
                            totalAmount: 0
                        });
                    }
                    
                    const link = linkMap.get(linkKey);
                    link.transactions.push({
                        date: tx.date,
                        time: tx.time,
                        amount: tx.amount,
                        description: tx.description
                    });
                    link.totalAmount += tx.amount;
                });
                
                // Convert to arrays
                const nodesArray = Array.from(nodes.values());
                const linksArray = Array.from(linkMap.values());
                
                return {
                    nodes: nodesArray,
                    links: linksArray
                };
            }
        };

        // UI controllers
        const ui = {
            init() {
                // File input - handle multiple files
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    const files = Array.from(e.target.files);
                    if (files.length > 0) this.handleFiles(files);
                });
                
                // Buttons
                document.getElementById('analyzeBtn').addEventListener('click', () => this.analyze());
                document.getElementById('zoomInBtn').addEventListener('click', () => {
                    app.svg.transition().call(app.zoom.scaleBy, 1.3);
                });
                document.getElementById('zoomOutBtn').addEventListener('click', () => {
                    app.svg.transition().call(app.zoom.scaleBy, 0.7);
                });
                document.getElementById('fitBtn').addEventListener('click', () => {
                    networkVis.fitToScreen();
                });
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                
                // Contact button
                document.getElementById('contactBtn').addEventListener('click', () => this.showContactModal());
                
                // Context menu event listeners
                this.setupContextMenu();
            },
            
            handleFiles(files) {
                const fileNames = files.map(f => f.name).join(', ');
                document.getElementById('fileName').textContent = `${files.length} ไฟล์: ${fileNames}`;
                document.getElementById('fileInfo').style.display = 'flex';
                document.getElementById('analyzeBtn').disabled = false;
                app.data = files;
            },
            
            setupContextMenu() {
                // Theme icon clicks in context menu
                document.querySelectorAll('.theme-icon').forEach(icon => {
                    icon.addEventListener('click', (e) => {
                        const theme = e.target.dataset.theme;
                        if (app.contextMenu.targetNode) {
                            networkVis.applyThemeToSingleNode(app.contextMenu.targetNode.id, theme);
                            
                            // Update active state
                            document.querySelectorAll('.theme-icon').forEach(i => i.classList.remove('active'));
                            e.target.classList.add('active');
                        }
                        networkVis.hideContextMenu();
                    });
                });
                
                // Delete node button in context menu
                document.getElementById('deleteNode').addEventListener('click', () => {
                    if (app.contextMenu.targetNode) {
                        networkVis.toggleNodeDeletion(app.contextMenu.targetNode.id);
                    }
                    networkVis.hideContextMenu();
                });
                
                // Hide context menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.context-menu') && !e.target.closest('.node')) {
                        networkVis.hideContextMenu();
                    }
                });
                
                // Prevent context menu on right click outside nodes
                document.addEventListener('contextmenu', (e) => {
                    if (!e.target.closest('.node')) {
                        networkVis.hideContextMenu();
                    }
                });
            },
            
            showContactModal() {
                const modal = document.getElementById('contactModal');
                modal.style.display = 'flex';
                setTimeout(() => modal.classList.add('show'), 10);
                
                // Setup modal close events
                document.getElementById('closeModal').onclick = () => this.hideContactModal();
                modal.onclick = (e) => {
                    if (e.target === modal) this.hideContactModal();
                };
                
                // ESC key to close
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') this.hideContactModal();
                });
            },
            
            hideContactModal() {
                const modal = document.getElementById('contactModal');
                modal.classList.remove('show');
                setTimeout(() => modal.style.display = 'none', 300);
            },
            
            async analyze() {
                if (!app.data || app.data.length === 0) return;
                
                try {
                    this.showLoading(true);
                    
                    // Read and process data from multiple files
                    const rawDataArray = [];
                    const files = Array.isArray(app.data) ? app.data : [app.data];
                    
                    for (const file of files) {
                        const rawData = await dataProcessor.readFile(file);
                        rawDataArray.push(rawData);
                    }
                    
                    const transactions = dataProcessor.processTransactions(rawDataArray);
                    const network = dataProcessor.buildNetwork(transactions);
                    
                    app.network = network;
                    
                    // Render network
                    networkVis.render(network);
                    
                } catch (error) {
                    console.error('Analysis error:', error);
                    alert('เกิดข้อผิดพลาด: ' + error.message);
                } finally {
                    this.showLoading(false);
                }
            },
            
            showLoading(show) {
                document.getElementById('loadingOverlay').style.display = show ? 'flex' : 'none';
            },
            
            reset() {
                app.data = [];
                app.network = null;
                app.pinnedNode = null;
                app.deletedNodes.clear();
                
                document.getElementById('fileInput').value = '';
                document.getElementById('fileInfo').style.display = 'none';
                document.getElementById('analyzeBtn').disabled = true;
                
                // Hide context menu
                networkVis.hideContextMenu();
                
                if (app.svg) {
                    app.svg.selectAll('*').remove();
                }
            }
        };

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            ui.init();
        });
    </script>
</body>
</html>